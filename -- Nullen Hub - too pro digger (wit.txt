-- Nullen Hub: Fixed incomplete statement and command notifications
local Players = game:GetService("Players")
local StarterGui = game:GetService("StarterGui")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TeleportService = game:GetService("TeleportService")
local TextChatService = game:GetService("TextChatService")

-- Initialize global variables safely
local function SafeGetgenv()
    if typeof(getgenv) ~= "function" then
        return {}
    end
    return getgenv()
end

local env = SafeGetgenv()
env.LoveList = env.LoveList or {}
env.Configs = env.Configs or {}
env.Whitelisted = env.Whitelisted or {}
env.FlingForce = env.FlingForce or 1e6 -- Safer default
env.FlingSpin = env.FlingSpin or 50
env.FlingPower = env.FlingPower or 1000 -- Safer default
env.FlySpeed = env.FlySpeed or 85
env.KissActive = env.KissActive or false
env.KissConn = env.KissConn or nil
env.KissBodyVel = env.KissBodyVel or nil
env.KissBodyGyro = env.KissBodyGyro or nil
env.KissOriginalWalkSpeed = env.KissOriginalWalkSpeed or nil
env.KissOriginalJumpPower = env.KissOriginalJumpPower or nil
env.FlingActive = env.FlingActive or false

local Player = Players.LocalPlayer
local Connections = {} -- Track all connections
local processedMessages = {} -- Deduplicate messages
local maxMessages = 100 -- Limit deduplication table size
local VelocityThreshold = 600 -- studs/sec
local AntiVoidEnabled = false
local AntiVoidConn = nil
local VOID_CHECK_Y = Workspace and Workspace.FallenPartsDestroyHeight or -100
local AntiFallDamageActive = false
local AntiFallDamageConns = {}
local Flying = false
local ctrl = {f=0, b=0, l=0, r=0, u=0, d=0}
local bv, bg, flyConn, hum
local lastSafeCFrame
local charRemovingConn, charAddedConn, lastRespawnPos
local StopVelConn
local SpinConn
local loopGotoConn
local NoDamageConn
local NoclipConn

-- === UTILITY FUNCTIONS ===
local function Message(title, text, duration)
    local success, err = pcall(function()
        StarterGui:SetCore("SendNotification", {
            Title = title,
            Text = text,
            Duration = duration or 3
        })
    end)
    if not success then
        warn("[NullenHub Notification Failed] Title: " .. tostring(title) .. ", Text: " .. tostring(text) .. ", Error: " .. tostring(err))
        print("[NullenHub Fallback] " .. tostring(title) .. ": " .. tostring(text))
    else
        print("[NullenHub Notification] Title: " .. tostring(title) .. ", Text: " .. tostring(text))
    end
end

local function SafeDestroy(obj)
    if obj and typeof(obj) == "Instance" and obj.Parent then
        pcall(function() obj:Destroy() end)
    end
end

local function GetCharacterHumanoid()
    local char = Player.Character or Player.CharacterAdded:Wait()
    local root = char:FindFirstChild("HumanoidRootPart") or char:WaitForChild("HumanoidRootPart", 5)
    local hum = char:FindFirstChildOfClass("Humanoid") or char:WaitForChild("Humanoid", 5)
    return root, hum
end

local function FindPlayer(query)
    if not query then return nil end
    query = query:lower()
    for _, p in ipairs(Players:GetPlayers()) do
        if p.Name:lower():find(query) or p.DisplayName:lower():find(query) then
            return p
        end
    end
    return nil
end

local function CleanupConnections()
    for key, conn in pairs(Connections) do
        if conn then
            pcall(function() conn:Disconnect() end)
            Connections[key] = nil
        end
    end
end

-- === SUPPORTING FUNCTIONS ===
local function OpenTextbox()
    local coreGui = game:GetService("CoreGui")
    local existing = coreGui:FindFirstChild("NullenHubTextbox")
    if existing then
        existing:Destroy()
    end
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "NullenHubTextbox"
    screenGui.Parent = coreGui
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 300, 0, 50)
    frame.Position = UDim2.new(0.5, -150, 0.1, 0)
    frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    frame.BorderSizePixel = 2
    frame.Parent = screenGui
    local textBox = Instance.new("TextBox")
    textBox.Size = UDim2.new(0.9, 0, 0.6, 0)
    textBox.Position = UDim2.new(0.05, 0, 0.2, 0)
    textBox.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    textBox.TextColor3 = Color3.fromRGB(255, 255, 255)
    textBox.Text = ""
    textBox.PlaceholderText = "Enter command..."
    textBox.Parent = frame
    Connections["Textbox"] = textBox.FocusLost:Connect(function(enterPressed)
        if enterPressed and textBox.Text ~= "" then
            HandleChat(Player, textBox.Text, true)
            textBox.Text = ""
        end
    end)
    Message("Textbox", "Textbox opened. Type commands here!", 2)
end

local function CloseTextbox()
    local coreGui = game:GetService("CoreGui")
    local screenGui = coreGui:FindFirstChild("NullenHubTextbox")
    if screenGui then
        screenGui:Destroy()
        Connections["Textbox"] = nil
        Message("Textbox", "Textbox closed.", 2)
    else
        Message("Textbox", "No textbox found to close.", 2)
    end
end

local function StopVelocity(duration)
    if StopVelConn then
        StopVelConn:Disconnect()
        Connections["StopVel"] = nil
    end
    local root, hum = GetCharacterHumanoid()
    if not root or not hum then
        Message("StopVel", "No character found.", 2)
        return
    end
    StopVelConn = RunService.Heartbeat:Connect(function()
        pcall(function()
            root.Velocity = Vector3.new(0, 0, 0)
            if root.AssemblyLinearVelocity then
                root.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
            end
        end)
    end)
    Connections["StopVel"] = StopVelConn
    task.spawn(function()
        task.wait(duration)
        if StopVelConn then
            StopVelConn:Disconnect()
            Connections["StopVel"] = nil
            StopVelConn = nil
        end
    end)
end

local function CancelStopVelocity()
    if StopVelConn then
        StopVelConn:Disconnect()
        Connections["StopVel"] = nil
        StopVelConn = nil
        Message("StopVel", "Cancelled velocity stop.", 2)
    else
        Message("StopVel", "No active velocity stop to cancel.", 2)
    end
end

local function CollectConfig()
    return {
        FlingForce = env.FlingForce,
        FlingSpin = env.FlingSpin,
        FlingPower = env.FlingPower,
        FlySpeed = env.FlySpeed,
        LoveList = env.LoveList,
        Whitelisted = env.Whitelisted
    }
end

local function ApplyConfig(cfg)
    if not cfg then return end
    if cfg.FlingForce then env.FlingForce = cfg.FlingForce end
    if cfg.FlingSpin then env.FlingSpin = cfg.FlingSpin end
    if cfg.FlingPower then env.FlingPower = cfg.FlingPower end
    if cfg.FlySpeed then env.FlySpeed = cfg.FlySpeed end
    if cfg.LoveList then env.LoveList = cfg.LoveList end
    if cfg.Whitelisted then env.Whitelisted = cfg.Whitelisted end
end

local function SkidFlingWithSafeReturn(target)
    local char = Player.Character
    if not char or not char.PrimaryPart then
        Message("Fling", "No character found.", 2)
        return
    end
    local root = char.PrimaryPart
    local originalPos = root.CFrame
    local targetChar = target.Character
    if not targetChar or not targetChar.PrimaryPart then
        Message("Fling", "Target character not found.", 2)
        return
    end
    local targetRoot = targetChar.PrimaryPart
    local targetHum = targetChar:FindFirstChildOfClass("Humanoid")
    if not targetHum then
        Message("Fling", "Target humanoid not found.", 2)
        return
    end
    root.CFrame = targetRoot.CFrame * CFrame.new(0, 0, 2)
    local bv = Instance.new("BodyVelocity")
    bv.MaxForce = Vector3.new(env.FlingForce, env.FlingForce, env.FlingForce)
    bv.P = env.FlingPower
    bv.Velocity = Vector3.new(0, 0, 0)
    bv.Parent = root
    local bav = Instance.new("BodyAngularVelocity")
    bav.MaxTorque = Vector3.new(env.FlingForce, env.FlingForce, env.FlingForce)
    bav.AngularVelocity = Vector3.new(env.FlingSpin, env.FlingSpin, env.FlingSpin)
    bav.Parent = root
    env.FlingActive = true
    local conn
    conn = RunService.Heartbeat:Connect(function()
        if not env.FlingActive or not target or not target.Parent or not targetRoot.Parent then
            SafeDestroy(bv)
            SafeDestroy(bav)
            if conn then conn:Disconnect() end
            return
        end
        if targetHum.Health <= 0 or targetRoot.Velocity.Magnitude > VelocityThreshold then
            env.FlingActive = false
        end
        bav.AngularVelocity = Vector3.new(env.FlingSpin, env.FlingSpin, env.FlingSpin)
        local predictionTime = math.clamp(targetRoot.Velocity.Magnitude / 200, 0.1, 0.5)
        local predictedPos = targetRoot.Position + targetRoot.Velocity * predictionTime
        local offset = targetHum.MoveDirection.Magnitude > 0 and targetHum.MoveDirection.Unit * 3 or Vector3.new(0, 0, 0)
        local direction = (predictedPos + offset - root.Position).Unit
        bv.Velocity = direction * env.FlingPower
    end)
    Connections["Fling"] = conn
    task.spawn(function()
        while env.FlingActive and root.Parent do
            task.wait(0.03)
        end
        if root and root.Parent then
            local VELOCITY_THRESHOLD = 5
            while root.Parent and root.AssemblyLinearVelocity.Magnitude > VELOCITY_THRESHOLD do
                pcall(function()
                    root.CFrame = originalPos
                    root.Velocity = Vector3.new(0, 0, 0)
                    if root.AssemblyLinearVelocity then
                        root.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                    end
                end)
                task.wait(0.03)
            end
        end
        SafeDestroy(bv)
        SafeDestroy(bav)
        if conn then conn:Disconnect() end
        Connections["Fling"] = nil
        env.FlingActive = false
    end)
end

local function StartWalkFling()
    local root, hum = GetCharacterHumanoid()
    if not root or not hum then
        Message("WalkFling", "No character found.", 2)
        return
    end
    env.FlingActive = true
    local bv = Instance.new("BodyVelocity")
    bv.MaxForce = Vector3.new(math.huge, 0, math.huge)
    bv.Velocity = Vector3.new(0, 0, 0)
    bv.Parent = root
    local spin = Instance.new("BodyAngularVelocity")
    spin.MaxTorque = Vector3.new(0, env.FlingSpin, 0)
    spin.AngularVelocity = Vector3.new(0, env.FlingForce, 0)
    spin.Parent = root
    Connections["WalkFling"] = RunService.Heartbeat:Connect(function()
        if not env.FlingActive then
            SafeDestroy(bv)
            SafeDestroy(spin)
            Connections["WalkFling"] = nil
        end
    end)
end

local function StopWalkFling()
    env.FlingActive = false
    local root = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
    if root then
        for _, v in ipairs(root:GetChildren()) do
            if v:IsA("BodyVelocity") or v:IsA("BodyAngularVelocity") then
                SafeDestroy(v)
            end
        end
    end
    if Connections["WalkFling"] then
        Connections["WalkFling"]:Disconnect()
        Connections["WalkFling"] = nil
    end
    Message("WalkFling", "Stopped walk fling.", 2)
end

local function EnableInstaRespawn()
    if charAddedConn then charAddedConn:Disconnect() end
    if charRemovingConn then charRemovingConn:Disconnect() end
    local root, hum = GetCharacterHumanoid()
    if not root or not hum then
        Message("InstaRespawn", "No character found.", 2)
        return
    end
    lastRespawnPos = root.CFrame
    charRemovingConn = Player.CharacterRemoving:Connect(function()
        local currentRoot = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
        if currentRoot then
            lastRespawnPos = currentRoot.CFrame
        end
    end)
    charAddedConn = Player.CharacterAdded:Connect(function(char)
        local newRoot = char:WaitForChild("HumanoidRootPart", 5)
        if newRoot and lastRespawnPos then
            task.wait(0.1)
            pcall(function() newRoot.CFrame = lastRespawnPos end)
        end
    end)
    Connections["InstaRespawnRemoving"] = charRemovingConn
    Connections["InstaRespawnAdded"] = charAddedConn
    Message("InstaRespawn", "Enabled instant respawn.", 2)
end

local function DisableInstaRespawn()
    if charRemovingConn then charRemovingConn:Disconnect() end
    if charAddedConn then charAddedConn:Disconnect() end
    Connections["InstaRespawnRemoving"] = nil
    Connections["InstaRespawnAdded"] = nil
    charRemovingConn = nil
    charAddedConn = nil
    lastRespawnPos = nil
    Message("InstaRespawn", "Disabled instant respawn.", 2)
end

local function StartAntiVoid()
    if AntiVoidConn then return end
    AntiVoidConn = RunService.Heartbeat:Connect(function()
        local char = Player.Character
        if not char then return end
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        local y = hrp.Position.Y
        local velY = 0
        pcall(function() velY = hrp.AssemblyLinearVelocity.Y or hrp.Velocity.Y or 0 end)
        if y > (VOID_CHECK_Y + 10) and velY > -80 then
            lastSafeCFrame = hrp.CFrame
        end
        if y <= VOID_CHECK_Y + 1 then
            local rayOrigin = hrp.Position + Vector3.new(0, 100, 0)
            local rayDir = Vector3.new(0, -5000, 0)
            local params = RaycastParams.new()
            params.FilterDescendantsInstances = {char}
            params.FilterType = Enum.RaycastFilterType.Blacklist
            local result = Workspace:Raycast(rayOrigin, rayDir, params)
            if result and result.Position then
                local targetCFrame = CFrame.new(result.Position + Vector3.new(0, 5, 0))
                pcall(function() hrp.CFrame = targetCFrame end)
            elseif lastSafeCFrame then
                pcall(function() hrp.CFrame = lastSafeCFrame end)
            else
                local spawn = Workspace:FindFirstChildOfClass("SpawnLocation")
                if spawn and spawn:IsA("BasePart") then
                    pcall(function() hrp.CFrame = spawn.CFrame + Vector3.new(0, 5, 0) end)
                end
            end
            task.wait(0.2)
        end
    end)
    Connections["AntiVoid"] = AntiVoidConn
end

local function StopAntiVoid()
    if AntiVoidConn then
        AntiVoidConn:Disconnect()
        Connections["AntiVoid"] = nil
        AntiVoidConn = nil
    end
end

local function EnableAntiVoid()
    if AntiVoidEnabled then
        Message("AntiVoid", "Anti-void already enabled.", 2)
        return
    end
    AntiVoidEnabled = true
    VOID_CHECK_Y = Workspace and Workspace.FallenPartsDestroyHeight or -100
    StartAntiVoid()
    Message("AntiVoid", "Enabled anti-void rescue.", 2)
end

local function DisableAntiVoid()
    if not AntiVoidEnabled then
        Message("AntiVoid", "Anti-void already disabled.", 2)
        return
    end
    AntiVoidEnabled = false
    StopAntiVoid()
    Message("AntiVoid", "Disabled anti-void rescue.", 2)
end

local function EnableAntiFallDamage()
    for _, conn in ipairs(AntiFallDamageConns) do
        if conn then conn:Disconnect() end
    end
    AntiFallDamageConns = {}
    AntiFallDamageActive = true
    local root, hum = GetCharacterHumanoid()
    if not root or not hum then
        Message("AntiFallDamage", "No character found.", 2)
        return
    end
    AntiFallDamageConns[1] = hum.StateChanged:Connect(function(old, new)
        if new == Enum.HumanoidStateType.FallingDown or new == Enum.HumanoidStateType.Ragdoll then
            hum:ChangeState(Enum.HumanoidStateType.Running)
        end
    end)
    AntiFallDamageConns[2] = RunService.Heartbeat:Connect(function()
        if root.Velocity.Magnitude > VelocityThreshold then
            pcall(function()
                root.Velocity = Vector3.new(root.Velocity.X, math.clamp(root.Velocity.Y, -100, 100), root.Velocity.Z)
                if root.AssemblyLinearVelocity then
                    root.AssemblyLinearVelocity = Vector3.new(root.Velocity.X, math.clamp(root.Velocity.Y, -100, 100), root.Velocity.Z)
                end
            end)
        end
    end)
    Connections["AntiFallDamage1"] = AntiFallDamageConns[1]
    Connections["AntiFallDamage2"] = AntiFallDamageConns[2]
    Message("AntiFallDamage", "Enabled anti-fall damage.", 2)
end

local function DisableAntiFallDamage()
    for _, conn in ipairs(AntiFallDamageConns) do
        if conn then conn:Disconnect() end
    end
    AntiFallDamageConns = {}
    AntiFallDamageActive = false
    Message("AntiFallDamage", "Disabled anti-fall damage.", 2)
end

local function EnableNoDamage()
    if NoDamageConn then NoDamageConn:Disconnect() end
    local hum = Player.Character and Player.Character:FindFirstChildOfClass("Humanoid")
    if not hum then
        Message("NoDamage", "No humanoid found.", 2)
        return
    end
    NoDamageConn = hum:GetPropertyChangedSignal("Health"):Connect(function()
        pcall(function() hum.Health = hum.MaxHealth end)
    end)
    Connections["NoDamage"] = NoDamageConn
    Message("NoDamage", "Enabled no damage.", 2)
end

local function DisableNoDamage()
    if NoDamageConn then
        NoDamageConn:Disconnect()
        Connections["NoDamage"] = nil
        NoDamageConn = nil
    end
    Message("NoDamage", "Disabled no damage.", 2)
end

local function StartFly(speed)
    if Flying then
        Message("Fly", "Already flying.", 2)
        return
    end
    Flying = true
    env.FlySpeed = tonumber(speed) or env.FlySpeed or 85
    local hrp, curHum = GetCharacterHumanoid()
    hum = curHum
    if not hrp or not hum then
        Flying = false
        Message("Fly", "No character found.", 2)
        return
    end
    hum.PlatformStand = true
    SafeDestroy(bv)
    SafeDestroy(bg)
    if flyConn then flyConn:Disconnect() end
    bv = Instance.new("BodyVelocity")
    bv.MaxForce = Vector3.new(1e6, 1e6, 1e6)
    bv.Velocity = Vector3.new(0, 0, 0)
    bv.Parent = hrp
    bg = Instance.new("BodyGyro")
    bg.MaxTorque = Vector3.new(9e5, 9e5, 9e5)
    bg.CFrame = hrp.CFrame
    bg.Parent = hrp
    flyConn = RunService.RenderStepped:Connect(function()
        if not Flying then return end
        local move = Vector3.new(ctrl.r - ctrl.l, ctrl.u - ctrl.d, ctrl.b - ctrl.f)
        if move.Magnitude > 0 then
            local cam = Workspace.CurrentCamera
            if cam then
                bv.Velocity = cam.CFrame:VectorToWorldSpace(move.Unit * env.FlySpeed)
            end
        else
            bv.Velocity = Vector3.new(0, 0, 0)
        end
        if Workspace.CurrentCamera then
            bg.CFrame = Workspace.CurrentCamera.CFrame
        end
    end)
    Connections["Fly"] = flyConn
    Message("Fly", "Enabled fly.", 2)
end

local function StopFly()
    if flyConn then
        flyConn:Disconnect()
        Connections["Fly"] = nil
        flyConn = nil
    end
    SafeDestroy(bv)
    SafeDestroy(bg)
    bv = nil
    bg = nil
    local char = Player.Character
    if char then
        local currentHum = char:FindFirstChildOfClass("Humanoid")
        if currentHum then currentHum.PlatformStand = false end
    end
    hum = nil
    Flying = false
    ctrl = {f=0, b=0, l=0, r=0, u=0, d=0}
    Message("Fly", "Disabled fly.", 2)
end

local function EnableSpin(speed)
    if SpinConn then
        Message("Spin", "Already spinning.", 2)
        return
    end
    speed = tonumber(speed) or 10
    SpinConn = RunService.Heartbeat:Connect(function()
        local root = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
        if root then
            root.CFrame = root.CFrame * CFrame.Angles(0, math.rad(speed), 0)
        end
    end)
    Connections["Spin"] = SpinConn
    Message("Spin", "Spinning enabled.", 2)
end

local function DisableSpin()
    if SpinConn then
        SpinConn:Disconnect()
        Connections["Spin"] = nil
        SpinConn = nil
        Message("Spin", "Spinning disabled.", 2)
    else
        Message("Spin", "Not spinning.", 2)
    end
end

local function LoopGoto(target)
    if loopGotoConn then
        loopGotoConn:Disconnect()
        Connections["LoopGoto"] = nil
    end
    local root = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
    if not root or not target.Character or not target.Character:FindFirstChild("HumanoidRootPart") then
        Message("LoopGoto", "No character or target found.", 2)
        return
    end
    loopGotoConn = RunService.Heartbeat:Connect(function()
        if target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
            pcall(function()
                root.CFrame = target.Character.HumanoidRootPart.CFrame + Vector3.new(0, 3, 0)
            end)
        else
            if loopGotoConn then
                loopGotoConn:Disconnect()
                Connections["LoopGoto"] = nil
                loopGotoConn = nil
            end
        end
    end)
    Connections["LoopGoto"] = loopGotoConn
end

local function StopLoopGoto()
    if loopGotoConn then
        loopGotoConn:Disconnect()
        Connections["LoopGoto"] = nil
        loopGotoConn = nil
        Message("LoopGoto", "Stopped loopgoto.", 2)
    else
        Message("LoopGoto", "No active loopgoto to stop.", 2)
    end
end

local function EnableNoclip()
    if NoclipConn then
        Message("Noclip", "Noclip already enabled.", 2)
        return
    end
    NoclipConn = RunService.Stepped:Connect(function()
        local char = Player.Character
        if char then
            for _, part in ipairs(char:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end
    end)
    Connections["Noclip"] = NoclipConn
    Message("Noclip", "Enabled noclip.", 2)
end

local function DisableNoclip()
    if NoclipConn then
        NoclipConn:Disconnect()
        Connections["Noclip"] = nil
        NoclipConn = nil
        Message("Noclip", "Disabled noclip.", 2)
    else
        Message("Noclip", "Noclip already disabled.", 2)
    end
end

local function CmdStatus()
    local status = {
        "FlingActive: " .. tostring(env.FlingActive),
        "KissActive: " .. tostring(env.KissActive),
        "AntiVoid: " .. tostring(AntiVoidEnabled),
        "AntiFallDamage: " .. tostring(AntiFallDamageActive),
        "Flying: " .. tostring(Flying)
    }
    Message("CmdStatus", table.concat(status, ", "), 5)
end

local function FlingStatus()
    Message("FlingStatus", "Force: " .. env.FlingForce .. ", Spin: " .. env.FlingSpin .. ", Power: " .. env.FlingPower, 5)
end

local function SendIYCommand(cmd)
    -- Placeholder for Infinite Yield compatibility
    print("[NullenHub IY Command] " .. cmd)
end

-- === COMMAND SYSTEM ===
local Commands = {
    textbox = function() OpenTextbox() end,
    untextbox = function() CloseTextbox() end,
    join = function(args)
        local input = args[2] and args[2]:gsub("%s+", "")
        if not input then
            Message("Join", "No link provided.", 2)
            return
        end
        local placeId = tonumber(input:match("placeId=(%d+)") or input:match("https?://www%.roblox%.com/games/(%d+)"))
        local jobId = input:match("gameInstanceId=([%w%-]+)") or input:match("jobId=([%w%-]+)")
        if placeId and jobId then
            pcall(function() TeleportService:TeleportToPlaceInstance(placeId, jobId, Player) end)
            Message("Join", "Teleporting to Job " .. jobId, 3)
        else
            Message("Join", "Invalid link format! Use roblox://placeId=123&gameInstanceId=abc", 5)
        end
    end,
    stopvel = function(args)
        local dur = tonumber(args[2]) or 0.7
        StopVelocity(dur)
        Message("StopVel", "Stopped velocity for " .. tostring(dur) .. "s.", 2)
    end,
    stopvelocity = function(args) Commands.stopvel(args) end,
    breakvelocity = function(args) Commands.stopvel(args) end,
    ["0velocity"] = function(args) Commands.stopvel(args) end,
    cancelvel = function() CancelStopVelocity() end,
    config = function(args)
        local name = args[2] and args[2]:lower()
        if not name then
            Message("Config", "No config name provided.", 2)
            return
        end
        local cfg = env.Configs[name]
        if not cfg and typeof(getclipboard) == "function" then
            local text = getclipboard()
            local success, loaded = pcall(function() return game:GetService("HttpService"):JSONDecode(text:match("return%s+(.+)")) end)
            if success and loaded then
                cfg = loaded
                env.Configs[name] = cfg
                Message("Config", "Config '" .. name .. "' loaded from clipboard!", 3)
            end
        end
        if cfg then
            ApplyConfig(cfg)
            Message("Config", "Config '" .. name .. "' applied!", 3)
        else
            Message("Config", "Config '" .. name .. "' not found!", 2)
        end
    end,
    love = function(args)
        local target = FindPlayer(args[2])
        if not target then
            Message("Love", "Player '" .. tostring(args[2]) .. "' not found!", 3)
            return
        end
        env.LoveList[target.Name:lower()] = true
        Message("Love", target.DisplayName .. " added to your LoveList â¤ï¸", 3)
    end,
    unlove = function(args)
        local name = args[2] and args[2]:lower()
        if not name then
            Message("Love", "No player name provided.", 3)
            return
        end
        local target = FindPlayer(name)
        if env.LoveList[name] then
            env.LoveList[name] = nil
            Message("Love", (target and target.DisplayName or name) .. " removed from your LoveList ðŸ’”", 3)
        else
            Message("Love", "Player '" .. name .. "' is not in your LoveList!", 3)
        end
    end,
    kiss = function(p)
        if p == Player then
            Message("Love", "You can't kiss yourself!", 2)
            return
        end
        if env.KissActive then
            Message("Love", "Kiss already active!", 2)
            return
        end
        local myChar = Player.Character
        local theirChar = p.Character
        if not myChar or not theirChar then
            Message("Love", "Character not found!", 2)
            env.KissActive = false
            return
        end
        local myRoot = myChar:FindFirstChild("HumanoidRootPart")
        local theirRoot = theirChar:FindFirstChild("HumanoidRootPart")
        local myHum = myChar:FindFirstChildOfClass("Humanoid")
        if not myRoot or not theirRoot or not myHum then
            Message("Love", "Missing character parts!", 2)
            env.KissActive = false
            return
        end
        env.KissActive = true
        if env.KissConn then
            env.KissConn:Disconnect()
            env.KissConn = nil
        end
        env.KissOriginalWalkSpeed = myHum.WalkSpeed
        env.KissOriginalJumpPower = myHum.JumpPower
        local originalAnchored = myRoot.Anchored
        local kissStartTime = tick()
        local kissDuration = 1.66
        local moveDuration = 0.5
        local initialWait = 0.2
        myHum.WalkSpeed = 0
        myHum.JumpPower = 0
        local targetCFrame = theirRoot.CFrame
        local startPos = targetCFrame * CFrame.new(0, 0, -2.2)
        local closePos = targetCFrame * CFrame.new(0, 0, -1.2)
        local lookAtCFrame = CFrame.new(startPos.Position, targetCFrame.Position)
        pcall(function()
            myRoot.Anchored = true
            myRoot.CFrame = lookAtCFrame
            task.wait(0.05)
            myRoot.Anchored = originalAnchored
        end)
        env.KissBodyVel = Instance.new("BodyVelocity")
        env.KissBodyVel.MaxForce = Vector3.new(1e6, 1e6, 1e6)
        env.KissBodyVel.Velocity = Vector3.new(0, 0, 0)
        env.KissBodyVel.Parent = myRoot
        env.KissBodyGyro = Instance.new("BodyGyro")
        env.KissBodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
        env.KissBodyGyro.P = 20000
        env.KissBodyGyro.D = 2000
        env.KissBodyGyro.Parent = myRoot
        env.KissConn = RunService.Heartbeat:Connect(function()
            if not env.KissActive or not theirChar or not theirChar.Parent or not theirRoot or not theirRoot.Parent then
                if env.KissConn then
                    env.KissConn:Disconnect()
                    env.KissConn = nil
                end
                if myRoot and myRoot.Parent then
                    pcall(function()
                        SafeDestroy(env.KissBodyVel)
                        SafeDestroy(env.KissBodyGyro)
                        env.KissBodyVel = nil
                        env.KissBodyGyro = nil
                        myHum.WalkSpeed = env.KissOriginalWalkSpeed or 16
                        myHum.JumpPower = env.KissOriginalJumpPower or 50
                        myRoot.Velocity = Vector3.new(0, 0, 0)
                        if myRoot.AssemblyLinearVelocity then
                            myRoot.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                        end
                        env.KissActive = false
                        env.KissOriginalWalkSpeed = nil
                        env.KissOriginalJumpPower = nil
                    end)
                end
                Message("Love", "Kiss ended! ðŸ’‹", 2)
                return
            end
            local elapsed = tick() - kissStartTime
            if elapsed > kissDuration then
                if env.KissConn then
                    env.KissConn:Disconnect()
                    env.KissConn = nil
                end
                if myRoot and myRoot.Parent then
                    pcall(function()
                        SafeDestroy(env.KissBodyVel)
                        SafeDestroy(env.KissBodyGyro)
                        env.KissBodyVel = nil
                        env.KissBodyGyro = nil
                        myHum.WalkSpeed = env.KissOriginalWalkSpeed or 16
                        myHum.JumpPower = env.KissOriginalJumpPower or 50
                        myRoot.Velocity = Vector3.new(0, 0, 0)
                        if myRoot.AssemblyLinearVelocity then
                            myRoot.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                        end
                        env.KissActive = false
                        env.KissOriginalWalkSpeed = nil
                        env.KissOriginalJumpPower = nil
                    end)
                end
                Message("Love", "Kiss ended! ðŸ’‹", 2)
                return
            end
            local targetCFrame = theirRoot.CFrame
            local startPos = targetCFrame * CFrame.new(0, 0, -2.2)
            local closePos = targetCFrame * CFrame.new(0, 0, -1.2)
            local currentPos
            if elapsed < initialWait then
                currentPos = startPos
            elseif elapsed < initialWait + moveDuration then
                local t = (elapsed - initialWait) / moveDuration
                currentPos = startPos:Lerp(closePos, t)
            elseif elapsed < initialWait + 2 * moveDuration then
                local t = (elapsed - initialWait - moveDuration) / moveDuration
                currentPos = closePos:Lerp(startPos, t)
            else
                currentPos = startPos
            end
            local lookAtCFrame = CFrame.new(currentPos.Position, targetCFrame.Position)
            pcall(function()
                myRoot.CFrame = lookAtCFrame
                env.KissBodyGyro.CFrame = lookAtCFrame
                myRoot.Velocity = Vector3.new(0, 0, 0)
                if myRoot.AssemblyLinearVelocity then
                    myRoot.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                end
            end)
        end)
        Connections["Kiss"] = env.KissConn
        Message("Love", p.DisplayName .. " kissed you! ðŸ’‹ðŸ˜˜", 3)
    end,
    unkiss = function()
        if env.KissConn then
            env.KissConn:Disconnect()
            env.KissConn = nil
            Connections["Kiss"] = nil
        end
        local myChar = Player.Character
        if myChar then
            local myRoot = myChar:FindFirstChild("HumanoidRootPart")
            local myHum = myChar:FindFirstChildOfClass("Humanoid")
            if myRoot and myHum then
                pcall(function()
                    SafeDestroy(env.KissBodyVel)
                    SafeDestroy(env.KissBodyGyro)
                    env.KissBodyVel = nil
                    env.KissBodyGyro = nil
                    myHum.WalkSpeed = env.KissOriginalWalkSpeed or 16
                    myHum.JumpPower = env.KissOriginalJumpPower or 50
                    myHum.PlatformStand = false
                    myRoot.Anchored = false
                    myRoot.Velocity = Vector3.new(0, 0, 0)
                    if myRoot.AssemblyLinearVelocity then
                        myRoot.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                    end
                    env.KissActive = false
                    env.KissOriginalWalkSpeed = nil
                    env.KissOriginalJumpPower = nil
                end)
                Message("Love", "Kiss stopped! ðŸ’”", 2)
            else
                Message("Love", "No character found to stop kiss.", 2)
            end
        else
            Message("Love", "No character found to stop kiss.", 2)
        end
        env.KissActive = false
    end,
    punish = function(p)
        local myHum = Player.Character and Player.Character:FindFirstChildOfClass("Humanoid")
        if myHum then
            myHum.Health = 0
            Message("Love", p.DisplayName .. " playfully punished you! ðŸ’¥", 3)
        else
            Message("Love", "Couldn't reset (no humanoid found).", 2)
        end
    end,
    cmdstatus = function() CmdStatus() end,
    flingstatus = function() FlingStatus() end,
    createconfig = function(args)
        local name = args[2] and args[2]:lower()
        if not name then
            Message("Config", "No config name provided.", 2)
            return
        end
        local cfg = CollectConfig()
        env.Configs[name] = cfg
        if typeof(setclipboard) == "function" then
            setclipboard("return " .. game:GetService("HttpService"):JSONEncode(cfg))
            Message("Config", "Config '" .. name .. "' saved and copied to clipboard!", 3)
        else
            Message("Config", "Config '" .. name .. "' saved locally!", 3)
        end
    end,
    listconfigs = function()
        local names = {}
        for k in pairs(env.Configs) do table.insert(names, k) end
        Message("Configs", "Configs: " .. table.concat(names, ", "), 5)
    end,
    antivoid = function() EnableAntiVoid() end,
    unantivoid = function() DisableAntiVoid() end,
    antifalldamage = function() EnableAntiFallDamage() end,
    unantifalldamage = function() DisableAntiFallDamage() end,
    fling = function(args)
        local targetName = args[2]
        if not targetName then
            Message("Fling", "No target specified.", 2)
            return
        end
        if targetName == "all" then
            local flungCount = 0
            for _, plr in ipairs(Players:GetPlayers()) do
                if plr ~= Player then
                    SkidFlingWithSafeReturn(plr)
                    flungCount = flungCount + 1
                end
            end
            Message("Fling", "Flung " .. flungCount .. " players.", 2)
        elseif targetName == "random" then
            local list = {}
            for _, plr in ipairs(Players:GetPlayers()) do
                if plr ~= Player then table.insert(list, plr) end
            end
            local target = list[math.random(1, #list)]
            if target then
                SkidFlingWithSafeReturn(target)
                Message("Fling", "Flung random player: " .. target.DisplayName, 2)
            else
                Message("Fling", "No valid players found.", 2)
            end
        else
            local target = FindPlayer(targetName)
            if target then
                SkidFlingWithSafeReturn(target)
                Message("Fling", "Flung " .. target.DisplayName, 2)
            else
                Message("Fling", "Target '" .. targetName .. "' not found.", 2)
            end
        end
    end,
    unfling = function()
        env.FlingActive = false
        Message("Fling", "Fling stopped.", 2)
    end,
    flingforce = function(args)
        local force = tonumber(args[2])
        if force then
            env.FlingForce = math.clamp(force, 1e3, 1e7)
            Message("FlingForce", "Set to " .. env.FlingForce, 2)
        else
            Message("FlingForce", "Invalid value.", 2)
        end
    end,
    flingspin = function(args)
        local spin = tonumber(args[2])
        if spin then
            env.FlingSpin = math.clamp(spin, 10, 1000)
            Message("FlingSpin", "Set to " .. env.FlingSpin, 2)
        else
            Message("FlingSpin", "Invalid value.", 2)
        end
    end,
    flingpower = function(args)
        local power = tonumber(args[2])
        if power then
            env.FlingPower = math.clamp(power, 100, 5000)
            Message("FlingPower", "Set to " .. env.FlingPower, 2)
        else
            Message("FlingPower", "Invalid value.", 2)
        end
    end,
    walkfling = function()
        StartWalkFling()
        Message("WalkFling", "Started walk fling.", 2)
        SendIYCommand(";walkfling")
    end,
    unwalkfling = function()
        StopWalkFling()
        Message("WalkFling", "Stopped walk fling.", 2)
        SendIYCommand(";unwalkfling")
    end,
    instarespawn = function() EnableInstaRespawn() end,
    uninstarespawn = function() DisableInstaRespawn() end,
    fov = function(args)
        local fov = tonumber(args[2])
        if fov and Workspace.CurrentCamera then
            Workspace.CurrentCamera.FieldOfView = math.clamp(fov, 10, 120)
            Message("FOV", "Set to " .. fov, 2)
        else
            Message("FOV", "Invalid FOV value or no camera.", 2)
        end
    end,
    nodamage = function() EnableNoDamage() end,
    damage = function() DisableNoDamage() end,
    wl = function(args)
        local query = args[2]
        if not query then
            Message("Whitelist", "No player specified.", 2)
            return
        end
        if query == "all" then
            for _, plr in ipairs(Players:GetPlayers()) do
                env.Whitelisted[plr.Name] = true
            end
            Message("Whitelist", "All players whitelisted.", 2)
        else
            local found = false
            for _, plr in ipairs(Players:GetPlayers()) do
                if plr.Name:lower():find(query:lower()) or plr.DisplayName:lower():find(query:lower()) then
                    env.Whitelisted[plr.Name] = true
                    Message("Whitelist", "Whitelisted " .. plr.DisplayName, 2)
                    found = true
                end
            end
            if not found then
                Message("Whitelist", "No players found matching '" .. query .. "'.", 2)
            end
        end
    end,
    unwl = function(args)
        local query = args[2]
        if not query then
            Message("Whitelist", "No player specified.", 2)
            return
        end
        if query:lower() == "all" then
            local localPlayerName = Player.Name
            local clearedCount = 0
            for name in pairs(env.Whitelisted) do
                if name ~= localPlayerName then
                    env.Whitelisted[name] = nil
                    clearedCount = clearedCount + 1
                end
            end
            Message("Whitelist", "Cleared " .. clearedCount .. " players from whitelist (kept local player).", 2)
        else
            local found = false
            for _, plr in ipairs(Players:GetPlayers()) do
                if plr.Name:lower():find(query:lower()) or plr.DisplayName:lower():find(query:lower()) then
                    if plr.Name ~= Player.Name then
                        env.Whitelisted[plr.Name] = nil
                        Message("Whitelist", "Removed " .. plr.DisplayName, 2)
                        found = true
                    else
                        Message("Whitelist", "Cannot unwhitelist yourself!", 2)
                    end
                end
            end
            if not found then
                Message("Whitelist", "No players found matching '" .. query .. "'.", 2)
            end
        end
    end,
    listwl = function()
        local wl = {}
        for name in pairs(env.Whitelisted) do table.insert(wl, name) end
        Message("Whitelist", "Whitelisted: " .. table.concat(wl, ", "), 5)
    end,
    jumppower = function(args)
        local jp = tonumber(args[2])
        local hum = Player.Character and Player.Character:FindFirstChildOfClass("Humanoid")
        if hum and jp then
            hum.UseJumpPower = true
            hum.JumpPower = math.clamp(jp, 0, 1000)
            Message("JumpPower", "Set to " .. jp, 2)
        else
            Message("JumpPower", "Invalid jump power value or no humanoid.", 2)
        end
    end,
    jp = function(args) Commands.jumppower(args) end,
    fly = function(args) StartFly(tonumber(args[2])) end,
    unfly = function() StopFly() end,
    speed = function(args)
        local val = tonumber(args[2])
        local hum = Player.Character and Player.Character:FindFirstChildOfClass("Humanoid")
        if hum and val then
            hum.WalkSpeed = math.clamp(val, 0, 1000)
            Message("Speed", "Set to " .. val, 2)
        else
            Message("Speed", "Invalid speed value or no humanoid.", 2)
        end
    end,
    spin = function(args) EnableSpin(args[2]) end,
    unspin = function() DisableSpin() end,
    loopgoto = function(args)
        local target = FindPlayer(args[2])
        if target then
            LoopGoto(target)
            Message("LoopGoto", "Looping to " .. target.DisplayName, 2)
        else
            Message("LoopGoto", "Player '" .. tostring(args[2]) .. "' not found.", 2)
        end
    end,
    unloopgoto = function() StopLoopGoto() end,
    noclip = function() EnableNoclip() end,
    clip = function() DisableNoclip() end,
    goto = function(args)
        local target = FindPlayer(args[2])
        if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
            local root = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
            if root then
                root.CFrame = target.Character.HumanoidRootPart.CFrame + Vector3.new(0, 3, 0)
                Message("Goto", "Teleported to " .. target.DisplayName, 2)
            else
                Message("Goto", "No local character found.", 2)
            end
        else
            Message("Goto", "Player '" .. tostring(args[2]) .. "' not found or no character.", 2)
        end
    end,
    tptool = function()
        local mouse = Player:GetMouse()
        if not mouse then
            Message("TP Tool", "Mouse not available.", 2)
            return
        end
        local tool = Instance.new("Tool")
        tool.RequiresHandle = false
        tool.Name = "TP Tool (Click TP)"
        tool.Activated:Connect(function()
            local pos = mouse.Hit.Position + Vector3.new(0, 2.5, 0)
            local root = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
            if root then
                root.CFrame = CFrame.new(pos)
                Message("TP Tool", "Teleported to mouse position.", 2)
            else
                Message("TP Tool", "No character found.", 2)
            end
        end)
        tool.Parent = Player.Backpack
        Message("TP Tool", "Added to backpack.", 2)
    end
}

-- === CHAT HANDLER ===
function HandleChat(p, msg, showNotifications)
    if not p or not msg or not p.UserId then
        warn("[NullenHub] Invalid player or message:", tostring(p), tostring(msg))
        return
    end

    print("[NullenHub] Processing message from " .. p.Name .. ": " .. msg)

    -- Deduplicate messages
    local messageKey = tostring(p.UserId) .. ":" .. msg
    if processedMessages[messageKey] then
        print("[NullenHub] Message already processed: " .. messageKey)
        return
    end
    processedMessages[messageKey] = true
    -- Limit processedMessages size
    local count = 0
    for _ in pairs(processedMessages) do count = count + 1 end
    if count > maxMessages then
        for k in pairs(processedMessages) do
            processedMessages[k] = nil
            break
        end
    end
    task.spawn(function()
        task.wait(2)
        processedMessages[messageKey] = nil
    end)

    -- Check for command prefix
    if msg:sub(1, 1) ~= "." then
        if not env.Whitelisted[p.Name] and p ~= Player then
            print("[NullenHub] Non-whitelisted player " .. p.Name .. " attempted non-command: " .. msg)
            return
        end
    else
        if not env.Whitelisted[p.Name] and p ~= Player then
            Message("Nullen Hub", "You do not have permission to use this command.", 3)
            print("[NullenHub] Permission denied for " .. p.Name .. ": " .. msg)
            return
        end
    end

    -- Parse command
    msg = msg:lower()
    local args = {}
    for word in msg:gmatch("%S+") do
        table.insert(args, word)
    end
    local cmd = args[1] and args[1]:sub(2) -- Remove "."
    if not cmd then
        print("[NullenHub] No command found in message: " .. msg)
        return
    end

    print("[NullenHub] Executing command: " .. cmd)

    -- Execute command
    local commandFunc = Commands[cmd]
    if commandFunc then
        local success, err = pcall(function()
            if cmd == "kiss" or cmd == "punish" then
                commandFunc(p) -- Pass player for kiss/punish
            else
                commandFunc(args) -- Pass arguments for other commands
            end
        end)
        if not success then
            warn("[NullenHub Command Error] Command: " .. cmd .. ", Error: " .. tostring(err))
            Message("Error", "Failed to execute command: " .. cmd, 3)
        else
            print("[NullenHub] Command executed successfully: " .. cmd)
        end
    else
        if showNotifications then
            Message("Nullen Hub", "Unknown command: " .. cmd, 2)
            print("[NullenHub] Unknown command: " .. cmd)
        end
    end
end

-- === INPUT HANDLING ===
Connections["InputBegan"] = UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    local kc = input.KeyCode
    if kc == Enum.KeyCode.W then ctrl.f = 1 end
    if kc == Enum.KeyCode.S then ctrl.b = 1 end
    if kc == Enum.KeyCode.A then ctrl.l = 1 end
    if kc == Enum.KeyCode.D then ctrl.r = 1 end
    if kc == Enum.KeyCode.Space then ctrl.u = 1 end
    if kc == Enum.KeyCode.E then ctrl.d = 1 end
end)

Connections["InputEnded"] = UserInputService.InputEnded:Connect(function(input)
    local kc = input.KeyCode
    if kc == Enum.KeyCode.W then ctrl.f = 0 end
    if kc == Enum.KeyCode.S then ctrl.b = 0 end
    if kc == Enum.KeyCode.A then ctrl.l = 0 end
    if kc == Enum.KeyCode.D then ctrl.r = 0 end
    if kc == Enum.KeyCode.Space then ctrl.u = 0 end
    if kc == Enum.KeyCode.E then ctrl.d = 0 end
end)

-- === CHAT HOOK ===
local function HookChat()
    local function hookPlayer(p)
        if p and p.UserId then
            Connections["Chatted_" .. p.UserId] = p.Chatted:Connect(function(msg)
                HandleChat(p, msg, false)
            end)
        end
    end

    -- Hook existing players
    for _, p in ipairs(Players:GetPlayers()) do
        hookPlayer(p)
    end

    -- Hook new players
    Connections["PlayerAdded"] = Players.PlayerAdded:Connect(function(p)
        hookPlayer(p)
    end)

    -- Hook TextChatService if available
    if TextChatService then
        Connections["TextChat"] = TextChatService.MessageReceived:Connect(function(textChatMessage)
            local sender = Players:GetPlayerByUserId(textChatMessage.SenderUserId)
            if sender then
                HandleChat(sender, textChatMessage.Text, true)
            end
        end)
    end

    Message("Nullen Hub", "Best command handler made by mankind up and working.", 3)
end

-- Initialize script with delay to ensure services are available
local function Initialize()
    if not Player or not Player.Parent then
        Connections["PlayerAddedInit"] = Players.PlayerAdded:Connect(function(p)
            if p == Player then
                Connections["PlayerAddedInit"]:Disconnect()
                Connections["PlayerAddedInit"] = nil
                env.Whitelisted[Player.Name] = true
                HookChat()
            end
        end)
    else
        env.Whitelisted[Player.Name] = true
        HookChat()
    end
end

-- Run initialization with a slight delay
task.spawn(function()
    task.wait(0.1) -- Ensure services are ready
    local success, err = pcall(Initialize)
    if not success then
        warn("[NullenHub Initialization Error] " .. tostring(err))
        print("[NullenHub Fallback] Initialization failed, retrying...")
        task.wait(1)
        pcall(Initialize)
    end
end)

-- Cleanup on script termination
game:BindToClose(function()
    CleanupConnections()
end)
